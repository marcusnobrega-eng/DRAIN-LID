%% =========================================================================
% üìÇ File Location: Physical_Functions_And_Utilities/get_boundary_values.m
%
% üîÅ FUNCTION: get_boundary_values
% Purpose   : Computes top and bottom boundary conditions (flux or head),
%             including ponding dynamics using HYDRUS-style flux inversion.
%
% Inputs:
%   h                   ‚Äì Pressure head profile [Nz √ó 1]
%   params              ‚Äì Struct containing all model parameters
%   t                   ‚Äì Current time [s]
%   ponding_depth_prev  ‚Äì Ponding depth at previous time step [m]
%
% Outputs:
%   top_bc              ‚Äì Value at top boundary (Neumann or Dirichlet) [m/s or m]
%   bottom_bc           ‚Äì Value at bottom boundary (Neumann, Dirichlet, or NaN)
%   ponding_depth       ‚Äì Updated surface ponding depth [m]
%   top_bc_type_used    ‚Äì Actual top BC used: 'neumann' or 'dirichlet'
%
% Author   : Marcus N√≥brega, Ph.D.
% Updated  : June 2025
%% =========================================================================

function [top_bc, bottom_bc, ponding_depth, top_bc_type_used] = ...
    get_boundary_values(h, params, t, ponding_depth_prev, delta, Gamma)

% === ‚¨ÜÔ∏è TOP BOUNDARY CONDITION ===========================================

top_bc_type_used = params.top_bc_type;

if top_bc_type_used == "neumann"

    % -- ‚õÖ Interpolate surface flux (rainfall/ET) ------------------------
    % surface_flux = interp1(params.surface_flux_time, params.surface_flux_vals, ...
    %     t, 'linear', 'extrap');  % [m/s]

    surface_flux = linear_interp(t, params.surface_flux_time, params.surface_flux_vals);


    % -- Estimate surface hydraulic conductivity and gradient ------------
    % Replace old K_vgm call with vanGenuchtenConductivity
    [K_vals, ~] = vanGenuchtenConductivity(h, params.alpha, params.n, params.Ks, 0.5);

    dhdz_top = (h(end) - h(end-1)) / params.dz(end);
    K_face = 0.5 * (K_vals(end) + K_vals(end-1));
    q_capacity_current = -K_face * (dhdz_top + 1);  % [m/s], downward capacity

    if surface_flux < 0
        % üåßÔ∏è Rainfall: Estimate surface pressure head h‚ÇÄ from imposed flux
        gradient = (0 - h(end-1)) / params.dz(end);
        q_capacity = -params.Ks(end) * (gradient + 1); % Assuming saturated conditions
        if abs(surface_flux) > abs(q_capacity) % Hortonian Flow
            h0 = ponding_depth_prev + abs(surface_flux - q_capacity) * params.dt; % [m]
        else
            h0 = nan; % All influx is absorved and we compute h with Newton-Raphson
        end
        % After iteration
        if h0 >= 0
            ponding_depth = h0;
            top_bc = ponding_depth;
            top_bc_type_used = "dirichlet";  % HYDRUS switch

        else
            ponding_depth = 0;
            top_bc = surface_flux;
            top_bc_type_used = "neumann";  % HYDRUS switch
        end


        % else
        %     % Now we already fixed the initial infiltration. We just need
        %     % to check if current rainfall is greater than
        % end


    elseif surface_flux > 0
        % Evaporation or Evapotranspiration?
        % Evaporation = Gamma * (ET0 + delta)
        % Gamma = 1; % DELETE
        % delta = 0; % mm/day
        potential_flux = Gamma * (surface_flux + delta/1000/86400); 
        % üí® Evaporation: flux limited by capillarity
        alpha_ET = feddes_alpha(h(end), params.h_lim_upper, params.h_lim_down);
        q_ETP = alpha_ET * potential_flux;

        if q_ETP > abs(q_capacity_current)
            top_bc = abs(q_capacity_current);  % upward limit
            ponding_depth = max(0, ponding_depth_prev - ...
                (q_ETP - abs(q_capacity_current)) * params.dt);
        else
            top_bc = q_ETP;
            ponding_depth = max(0, ponding_depth_prev);
        end

    else
        % No flux
        top_bc = 0;
        ponding_depth = ponding_depth_prev;
    end

elseif top_bc_type_used == "dirichlet"
    % üìè Fixed surface pressure head
    top_bc = params.top_bc_value;
    ponding_depth = max(top_bc, 0);

else
    error("‚ùå Unknown top BC type: %s", params.top_bc_type);
end

% === ‚¨áÔ∏è BOTTOM BOUNDARY CONDITION =======================================

switch params.bottom_bc_type
    case "neumann"
        % bottom_bc = interp1(params.bottom_flux_time, ...
        %     params.bottom_flux_vals, t, 'linear', 'extrap');

        bottom_bc = linear_interp(t, params.bottom_flux_time, params.bottom_flux_vals);

    case "dirichlet"
        bottom_bc = params.bottom_bc_value;

    case "free"
        % Free drainage (unit gradient): handled in residual
        bottom_bc = NaN;

    case "noflow"
        % Seepage/no-flow: handled in residual
        bottom_bc = NaN;

    otherwise
        error("‚ùå Unknown bottom BC type: %s", params.bottom_bc_type);
end
end


function [K, dKdh] = vanGenuchtenConductivity(h, alpha, n, Ks, l)
% Computes hydraulic conductivity K(h) and its derivative dK/dh
% using van Genuchten-Mualem model with numerical safeguards.
%
% Inputs:
%   h     - Pressure head [m] (negative for unsaturated soil)
%   alpha - van Genuchten parameter [1/m]
%   n     - van Genuchten parameter [-]
%   Ks    - Saturated hydraulic conductivity [m/s]
%   l     - Pore-connectivity parameter (commonly 0.5)
%
% Outputs:
%   K     - Hydraulic conductivity at pressure head h [m/s]
%   dKdh  - Derivative of K with respect to h [m/s per m]

% Ensure m is defined correctly
m = 1 - 1./n;

% Small tolerance to prevent numerical issues
epsilon = 1e-12;

% Effective saturation Se
Se = (1 + (alpha .* abs(h)).^n).^(-m);

% Limit Se to slightly below 1 to prevent division by zero
Se = min(Se, 1 - epsilon);

% Derivative of Se with respect to h
dSedh = -m .* n .* alpha.^n .* abs(h).^(n - 1) .* sign(h) .* (1 + (alpha .* abs(h)).^n).^(-m - 1);

% Mualem-van Genuchten conductivity function
term = (1 - (1 - Se.^(1./m)).^m).^2;
K = Ks .* Se.^l .* term;

% Derivative components
dA_dh = Ks .* l .* Se.^(l - 1) .* dSedh;

inner = 1 - Se.^(1./m);
inner = max(inner, epsilon);  % Prevent zero to negative power

dInner_dh = -(1./m) .* Se.^(1./m - 1) .* dSedh;

dTerm_dh = 2 * (1 - inner.^m) .* m .* inner.^(m - 1) .* dInner_dh;

% Final derivative dK/dh
dKdh = dA_dh .* term + Ks .* Se.^l .* dTerm_dh;

% Optional: If Se is essentially fully saturated, the derivative should be ~0
fully_saturated = Se >= (1 - 1e-8);
dKdh(fully_saturated) = 0;

end


function vq = linear_interp(tq, x, v)
% LINEAR_INTERP - Simple linear interpolation (no interp1)
% Supports v as 1D vector or 2D matrix (e.g., [Nz x Nt])
% Inputs:
%   tq ‚Äì query point (scalar)
%   x  ‚Äì time vector [1 x Nt]
%   v  ‚Äì values [Nz x Nt] or [1 x Nt]
% Output:
%   vq ‚Äì interpolated value at tq [Nz x 1] or scalar

    idx = find(x <= tq, 1, 'last');

    if isempty(idx) || idx >= length(x)
        idx = max(min(idx, length(x)-1), 1);  % Clamp
    end

    x0 = x(idx);
    x1 = x(idx+1);

    v0 = v(idx,:);
    v1 = v(idx+1,:);

    w = (tq - x0) / (x1 - x0);
    vq = v0 + w .* (v1 - v0);
end

function vq = previous_value(tq, x, v)
% PREVIOUS_VALUE - Return value at previous time-step (no interpolation)
% Supports v as 1D vector or 2D matrix (e.g., [Nz x Nt])
% Inputs:
%   tq ‚Äì query point (scalar)
%   x  ‚Äì time vector [1 x Nt]
%   v  ‚Äì values [Nz x Nt] or [1 x Nt]
% Output:
%   vq ‚Äì value at the last time <= tq [Nz x 1] or scalar

    idx = find(x <= tq, 1, 'last');  % Find last time <= tq

    if isempty(idx)
        idx = 1;  % Clamp to first index if tq is before all x
    end

    % Handle different shapes of v
    if isvector(v)
        vq = v(idx);
    else
        vq = v(:, idx);
    end
end
